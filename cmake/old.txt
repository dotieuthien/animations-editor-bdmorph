void MainScene::loadImage()
{
	QString filename = QFileDialog::getOpenFileName(0, tr("Choose model"), QString(), QLatin1String("*.png *.jpg *.bmp"));
	QImage image(filename);
	if (image.isNull()) return;

	image = image.scaled(350,350,Qt::KeepAspectRatio);
	image = image.mirrored(false,true);
	qWarning("width: %d, height: %d", image.width(), image.height()); 

	std::vector<QPointF> V; //vertices
	std::vector<std::pair<int,int> > E; //segments
	int Vmap[354][354] = {{0}}; //added stroke 2 in each side of the map
	int stroke = 2;
	for (int i=stroke; i<image.width()+stroke; i++) {
		for (int j=stroke; j<image.height()+stroke; j++) {
			if ((filename.endsWith("png") && qAlpha(image.pixel(i-stroke,j-stroke)) >= 250) ||
				((filename.endsWith("jpg") || filename.endsWith("bmp")) && qGray(image.pixel(i-stroke,j-stroke)) <= 250)) {
				for (int k=i-stroke; k<=i+stroke; k++) {
					for (int l=j-stroke; l<=j+stroke; l++) {
						Vmap[k][l] = -1;
					}
				}
			}
		}
	}

	int count = 0;
	for (int i=0; i<image.width()+2*stroke; i++) {
		for (int j=0; j<image.height()+2*stroke; j++) {
			if (Vmap[i][j] == -1) {
				if (Vmap[max(0,i-1)][j] == 0 || Vmap[i][max(0,j-1)] == 0 || 
					Vmap[min(image.width()+2*stroke-1,i+1)][j] == 0 || Vmap[i][min(image.height()+2*stroke-1,j+1)] == 0 ||
					Vmap[max(0,i-1)][max(0,j-1)] == 0 || Vmap[max(0,i-1)][min(image.height()+2*stroke-1,j+1)] == 0 ||
					Vmap[min(image.width()+2*stroke-1,i+1)][max(0,j-1)] == 0 || Vmap[min(image.width()+2*stroke-1,i+1)][min(image.height()+2*stroke-1,j+1)] == 0) {
						count++;
						Vmap[i][j] = count;
						V.push_back(QPointF(i,j));
				}
			}
		}
	}

	for (int i=0; i<image.width()+2*stroke; i++) {
		for (int j=0; j<image.height()+2*stroke; j++) {
			if (j+1 < image.height()+2*stroke && Vmap[i][j] > 0 && Vmap[i][j+1] > 0) {
				E.push_back(std::make_pair(Vmap[i][j],Vmap[i][j+1]));
			}
			if (i+1 < image.width()+2*stroke && Vmap[i][j] > 0 && Vmap[i+1][j] > 0) {
				E.push_back(std::make_pair(Vmap[i][j],Vmap[i+1][j]));
			}
		}
	}

	qWarning("\n#vertices: %d, #segments: %d", (int)V.size(), (int)E.size());

	std::ofstream outfile("temp.poly");
	//vertices
	outfile << V.size() << " 2 0 1" << endl;
	for (int i=1; i<=V.size(); i++) {
		outfile << i << ' ' << V[i-1].x()/(image.width()+stroke) << ' ' << V[i-1].y()/(image.height()+stroke) << " 1 " << endl;
	}
	//segments
	outfile << E.size() << " 1" << endl;
	for (int i=1; i<=E.size(); i++) {
		outfile << i << ' ' << E[i-1].first << ' ' << E[i-1].second << " 1 " << endl;
	}
	//holes
	outfile << '0' << endl;

	system("cc -O -o triangle triangle.c -lm");
	system("triangle -pqDgPNE temp");
}

extern "C" {
#include <amd.h>
#include <ldl.h>
#include <camd.h>
}


#define ALLOC_MEMORY(p,type,size) \
p = (type *) malloc ((((size) <= 0) ? 1 : (size)) * sizeof (type)); \
if (p == (type *) NULL) \
{ \
    qWarning ("malloc out of memory; requested %d elements of size %d\n", (int)size, (int)sizeof(type)) ; \
    exit(1) ; \
}

/***********************************************************************************************/

#define FREE_MEMORY(p,type) \
if (p != (type *) NULL) \
{ \
    free (p) ; \
    p = (type *) NULL ; \
}

void KVFModel::initialize()
{
    getP(P);
    Pcopy.copy(P);
    CholmodSparseMatrix covariance;
    CholmodSparseMatrix trans;

    /**********************************************************************/
    TimeMeasurment t;
    P.transpose(trans);
    printf("Transpose time: %f msec\n", t.measure_msec());

    /**********************************************************************/
    trans.multiply(P, covariance);
    printf("Covariance product time: %f msec\n", t.measure_msec());

    /**********************************************************************/
    printf("Computing permutation...\n");

    int n = 2*numVertices;
    LDL_int  *Parent, *Flag,  *Lp, *Lnz, *Pfw, *Pinv;
    ALLOC_MEMORY(Parent, LDL_int, n);
    ALLOC_MEMORY(Flag, LDL_int, n);
    ALLOC_MEMORY(Lp, LDL_int, n+1);
    ALLOC_MEMORY(Lnz, LDL_int, n);
    ALLOC_MEMORY(Pfw, LDL_int, n);
    ALLOC_MEMORY(Pinv, LDL_int, n);
    LDL_int *Ap = covariance.getAp();

    double Info[AMD_INFO];
    if (amd_order (n, Ap, covariance.getAi(), Pfw, (double *) NULL, Info) < AMD_OK) {
        printf("call to AMD failed\n");
        exit(1);
    }
    amd_control((double*)NULL);
    amd_info(Info);
    printf("AMD time: %f msec\n", t.measure_msec());
    /**********************************************************************/

    printf("Doing symbolic ldl...\n");
    ldl_symbolic (2*numVertices, Ap, covariance.getAi(), Lp, Parent, Lnz, Flag, Pfw, Pinv);
    printf("Symbolic time: %f\n", t.measure_msec());

    FREE_MEMORY(Parent, LDL_int);
    FREE_MEMORY(Flag, LDL_int);
    FREE_MEMORY(Lp, LDL_int);
    FREE_MEMORY(Lnz, LDL_int);
    FREE_MEMORY(Pfw, LDL_int);
    FREE_MEMORY(Pinv, LDL_int);
}


class ParallelMatrixMultiplier : public QThread
{
public:
    CholmodSparseMatrix *lhs, *rhs, *result;
    int firstRow, lastRow;

protected:
    void run() {
    	std::map<unsigned int, double> rowValues; // for a given column, holds nonzero values

        for (int i = firstRow; i < lastRow; i++) { // compute the i-th row
            rowValues.clear(); // start out with zeroes

            int end = lhs->rowEnd(i);

            for (int p = lhs->rowStart[i]; p < end; p++) { // for all elements in row i
                int k = lhs->column[p]; // this is the k-th column
                double value = lhs->values[p]; // value = element (i,k)

                int stop = rhs->rowEnd(k);
                for (int q = rhs->rowStart[k]; q < stop; q++) // look at row k in matrix m
                    rowValues[ rhs->column[q] ] += value * rhs->values[q]; // add (i,k) * (k,q)
            }

            // this better traverse in sorted order...
            int count = result->rowStart[i];
            for (auto it = rowValues.begin(); it != rowValues.end(); ++it) {
                result->column[count] = it->first;
                result->values[count] = it->second;
                count++;
            }
        }
    }
};

/******************************************************************************************************************************/
void CholmodSparseMatrix::parallelMultiply(CholmodSparseMatrix &m, CholmodSparseMatrix &result)
{
    ParallelMatrixMultiplier multipliers[N_THREADS];

    if (result.nr == 0) {
    	multiply(m,result);
    	return;
    }

    // assume that sparsity pattern of result is the same, although we can throw out some rows
    if (result.nr != nr) { // this is essentially a hack that only works because we're using this in one program
        result.numNonzero = result.rowEnd(nr-1);
        result.reshape(nr, m.nc, result.capacity);
    }

    int s = nr / N_THREADS;
    for (unsigned int i = 0; i < N_THREADS; i++) {
        multipliers[i].firstRow = i*s;
        multipliers[i].lastRow = (i+1)*s;
        multipliers[i].lhs = this;
        multipliers[i].rhs = &m;
        multipliers[i].result = &result;
    }
    multipliers[N_THREADS-1].lastRow = nr;

    for (unsigned int i = 0; i < N_THREADS; i++)
        multipliers[i].start();

    for (unsigned int i = 0; i < N_THREADS; i++)
        multipliers[i].wait();
}


